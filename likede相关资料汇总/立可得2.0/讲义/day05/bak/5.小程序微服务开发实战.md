# 第5章 小程序微服务开发实战

## 1. 小程序端功能概述

### 1.1 产品原型分析 







### 1.2 商品列表与商品详情

#### 1.2.1 实现思路

（1）用户选取售货机之后，小程序端扫码后将售货机编号传入到小程序后台接口

（2）小程序后台接口通过fegin调用售货机服务里的获取设备商品列表的接口来获取数据

（3）小程序后台接口通过fegin调用售货机服务里的商品详情接口获取详情数据返回给前端

#### 1.2.2 代码实现

在`service_common`项目中定义的SkuViewModel是用于需要展示的商品详情对象

在小程序后端服务中的`VMController`中添加获取商品列表和商品详情的RESTful接口方法实现

```java
@Autowired
private VMService vmService;
  
/**
     * 获取售货机商品列表
     * @param innerCode
     * @return
     */
@GetMapping("/skuList/{innerCode}")
public List<SkuViewModel> getSkuListByInnercode(@PathVariable String innerCode){
    return vmService.getAllSkuByInnerCode(innerCode);
}

/**
     * 扫码获取商品详情，用来后续支付
     * @param innerCode
     * @param skuId
     * @return
     */
@GetMapping("/sku/{innerCode}/{skuId}")
public SkuInfoViewModel getSku(@PathVariable String innerCode, @PathVariable String skuId){
    SkuViewModel skuViewModel = vmService.getSku(innerCode,skuId);
    SkuInfoViewModel skuInfo = new SkuInfoViewModel();
    BeanUtils.copyProperties(skuViewModel,skuInfo);
    VendingMachineViewModel vmInfo =vmService.getVMInfo(innerCode);
    if(vmInfo != null){
        skuInfo.setAddr(vmInfo.getNodeAddr());
        skuInfo.setInnerCode(innerCode);
    }

    return skuInfo;
}
```

### 1.3 获取openId

#### 1.3.1 openId简介 

（1）注册微信小程序、登录后台在设置中获得appId和secret(密钥)
（2）调用wx.login()接口获取登录凭证js_code
（3）调用wx.request()接口把js_code发送到服务器后台
（4）在服务器后台，已知appId、secret、js_code
然后调用如下官方提供的http接口，即可返回获取openId、session_key

官方提供了http接口地址为：
https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code

这是一个 HTTPS 接口，开发者服务器使用**登录凭证 code获取 session_key 和 openid。其中 session_key 是对用户数据进行[加密签名](https://www.w3cschool.cn/weixinapp/weixinapp-signature.html)的密钥。为了自身应用安全，**session_key 不应该在网络上传输。

**请求参数：**

| 参数         | 必填   | 说明                     |
| ---------- | ---- | ---------------------- |
| appid      | 是    | 小程序唯一标识                |
| secret     | 是    | 小程序的 app secret        |
| js_code    | 是    | 登录时获取的 code            |
| grant_type | 是    | 填写为 authorization_code |

**返回参数：**

| 参数          | 说明                                       |
| ----------- | ---------------------------------------- |
| openid      | 用户唯一标识                                   |
| session_key | 会话密钥                                     |
| unionid     | 用户在开放平台的唯一标识符。本字段在满足一定条件的情况下才返回。具体参看[UnionID机制说明](https://www.w3cschool.cn/weixinapp/weixinapp-open.html#unionid) |

**返回说明：**

```json
//正常返回的JSON数据包
{
      "openid": "OPENID",
      "session_key": "SESSIONKEY"
      "unionid":  "UNIONID"
}
//错误时返回JSON数据包(示例为Code无效)
{
    "errcode": 40029,
    "errmsg": "invalid code"
}
```

#### 1.3.2 代码实现







## 2. 小程序支付解决方案

### 2.1 需求分析 





### 2.2 实现思路  

整个业务的时序流程如下：

![](images/1-3.png)

因为我们立可得2.0里采用了微信小程序支付，所以需要和微信支付平台做对接，微信小程序支付流程如下：

![](images/1-4.jpg)





### 2.3 代码实现  

#### 2.3.1 对接微信支付  

（1）在订单服务`lkd_order_service`中添加微信支付的相关依赖

```xml
<dependency>
    <groupId>com.github.wxpay</groupId>
    <artifactId>wxpay-sdk</artifactId>
    <version>3.0.9</version>
</dependency>
```

（2）在订单服务中的consul配置中心添加微信支付相关的配置：

```yaml
wxpay:
  appId: xxxxxxxxxxxxxx #微信支付商户平台里的appId
  appSecret: xxxxxxxxxxxxxxxxx  #微信支付商户平台里的appSecret
  mchId: 1234567890 #商户号
  partnerKey: 123456 #商户的key
  notifyUrl: http://******/wxpay/payNotify #微信支付成功之后的回调地址
```

测试账号数据见配套资料

```yaml
wxpay:
  appId: wxb709cf6e6a7d9d2a
  appSecret: d9a9ff00a633cd7353a8925119063b01
  mchId: 1473426802
  partnerKey: T6m9iK73b0kn9g5v426MKfHQH7X8rKwb
  notifyUrl: https://lkd2-java.itheima.net/api/order-service/wxpay/payNotify
```

（3）创建微信支付相关配置映射类

```java
package com.lkd.conf;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties("wxpay")
@Data
public class WXConfig {
    private String appId;
    private String appSecret;
    private String mchId;
    private String partnerKey;
    private String notifyUrl = "";
}
```

（4）添加微信支付sdk需要实现的配置类WxPaySdkConfig

```java
package com.github.wxpay.sdk;

import com.lkd.conf.WXConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.InputStream;

@Component
public class WxPaySdkConfig extends WXPayConfig {
    @Autowired
    private WXConfig wxConfig;
  
    public String getAppID() {
        return wxConfig.getAppId();
    }

    public String getMchID() {
        return wxConfig.getMchId();
    }

    public String getKey() {
        return wxConfig.getPartnerKey();
    }

     InputStream getCertStream() {
        return null;
    }

     IWXPayDomain getWXPayDomain() {
        return new IWXPayDomain() {
            public void report(String s, long l, Exception e) {

            }

            public DomainInfo getDomain(WXPayConfig wxPayConfig) {
                return new DomainInfo("api.mch.weixin.qq.com",true);
            }
        };
    }
}
```

#### 2.3.2 发起支付请求   

（1）订单微服务lkd_order_service新建WXPayService，定义requestPay方法

```java
/**
 * 微信支付服务接口
 */
public interface WXPayService {

    /**
     * 调用统一下单接口发起支付
     * @param openId
     * @param orderNo
     * @return
     */
    String requestPay(String openId,String orderNo);
}
```

创建实现类WXPayServiceImpl实现发起支付方法

```java
@Service
@Slf4j
public class WXPayServiceImpl implements WXPayService {
    @Autowired
    private WXConfig wxConfig;
    @Autowired
    private WxPaySdkConfig wxPaySdkConfig;

    @Override
    public String requestPay(String openId, String orderNo) {
        OrderEntity orderEntity = orderService.getByOrderNo(orderNo);
        try{
            String nonce_str = WXPayUtil.generateNonceStr();
            //1.封装请求参数
            Map<String,String> map= Maps.newHashMap();
            map.put("appid",wxPaySdkConfig.getAppID());//公众账号ID
            map.put("mch_id",wxPaySdkConfig.getMchID());//商户号
            map.put("nonce_str", nonce_str);//随机字符串
            map.put("body","立可得");//商品描述
            map.put("out_trade_no",orderNo);//订单号
            map.put("total_fee",orderEntity.getAmount()+"");//金额
            map.put("spbill_create_ip","127.0.0.1");//终端IP
            map.put("notify_url",wxConfig.getNotifyUrl());//回调地址
            map.put("trade_type","JSAPI");//交易类型
            map.put("openid",openId);
            String xmlParam  = WXPayUtil.generateSignedXml(map, wxPaySdkConfig.getKey());
            System.out.println("参数："+xmlParam);
            orderService.updateById(orderEntity);
            //2.发送请求
            WXPayRequest wxPayRequest=new WXPayRequest(wxPaySdkConfig);
            String xmlResult = wxPayRequest.requestWithCert("/pay/unifiedorder", null, xmlParam, false);
            //3.解析返回结果
            Map<String, String> mapResult = WXPayUtil.xmlToMap(xmlResult);
            //返回状态码
            String return_code = (String) mapResult.get("return_code");
            //返回给移动端需要的参数
            Map<String, String> response = Maps.newHashMap();
            if(return_code.equals("SUCCESS")){
                // 业务结果
                String prepay_id = (String) mapResult.get("prepay_id");//返回的预付单信息
                if(Strings.isNullOrEmpty(prepay_id)){
                    log.error("prepay_id is null","当前订单可能已经被支付");
                    throw new LogicException("当前订单可能已经被支付");
                }
                response.put("appId",wxConfig.getAppId());
                response.put("package", "prepay_id=" + prepay_id);
                response.put("signType","MD5");
                response.put("nonceStr", WXPayUtil.generateNonceStr());

                Long timeStamp = System.currentTimeMillis() / 1000;
                response.put("timeStamp", timeStamp + "");//要将返回的时间戳转化成字符串，不然小程序端调用wx.requestPayment方法会报签名错误

                //再次签名，这个签名用于小程序端调用wx.requesetPayment方法
                String sign = WXPayUtil.generateSignature(response,wxConfig.getPartnerKey());
                response.put("paySign", sign);
                response.put("appId","");
                response.put("orderNo",orderNo);
                return JsonUtil.serialize(response);
            }else {
                log.error("调用微信统一下单接口失败",response);
                return null;
            }
        }catch (Exception ex){
            log.error("调用微信统一下单接口失败",ex);
            return "";
        }
    }
}
```



#### 2.3.3 支付回调处理







## 3. 独占式出货控制解决方案

### 3.1 需求分析

用户在立可得小程序中选取完商品之后点击支付后，要生成订单，完成微信扣款后向售货机下发出货通知，售货机出货完成后要更新订单状态。



### 3.2 实现思路

从上面的交互图可以看出微信小程序端需要：

（1）调用后台接口请求下单支付

（2）后台在调用微信统一下单接口之前先要获取openId，

（3）获取openId时需要客户端调用微信登录接口获取微信端返回的jsCode，并将该code传入后台，后台将该code传入微信端接口从而才能得到openId

（4）后台调用微信统一下单接口将相关数据传入到微信接口，此时微信平台会返回相关数据(其中包括prepay_id，也叫预付单信息)

（5）后台将得到的数据再次签名之后返回到前端(5个参数)

（6）前端根据后台返回的数据向微信端调起鉴权支付请求，如果通过则在小程序内部呼起微信支付

小程序调起支付数据签名字段列表：

| 字段名   | 变量名       | 必填   | 类型     | 示例值                                      | 描述                                       |
| ----- | --------- | ---- | ------ | ---------------------------------------- | ---------------------------------------- |
| 小程序ID | appId     | 是    | String | wxd678efh567hg6787                       | 微信分配的小程序ID                               |
| 时间戳   | timeStamp | 是    | String | 1490840662                               | 时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间        |
| 随机串   | nonceStr  | 是    | String | 5K8264ILTKCH16CQ2502SI8ZNMTM67VS         | 随机字符串，不长于32位。推荐[随机数生成算法](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=4_3) |
| 数据包   | package   | 是    | String | prepay_id=*wx2017033010242291fcfe0db70013231072* | 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*wx2017033010242291fcfe0db70013231072* |
| 签名方式  | signType  | 是    | String | MD5                                      | 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 |



小程序内支付的具体的实现思路如下：

(1) 在订单服务里封装和微信支付的相关接口，通过fegin暴露给小程序调用

(2) 在小程序中调用调用这些接口来实现支付的整个流程

### 3.3 代码实现

微信支付相关配置映射类

```java
package com.lkd.conf;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties("wxpay")
@Data
public class WXConfig {
    private String appId;
    private String appSecret;
    private String mchId;
    private String partnerKey;
    private String notifyUrl = "";
}
```
微信支付sdk需要实现的配置类

```java
package com.github.wxpay.sdk;

import com.lkd.conf.WXConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.InputStream;

@Component
public class WxPaySdkConfig extends WXPayConfig {
    @Autowired
    private WXConfig wxConfig;
    public String getAppID() {
        return wxConfig.getAppId();
    }

    public String getMchID() {
        return wxConfig.getMchId();
    }

    public String getKey() {
        return wxConfig.getPartnerKey();
    }

     InputStream getCertStream() {
        return null;
    }

     IWXPayDomain getWXPayDomain() {
        return new IWXPayDomain() {
            public void report(String s, long l, Exception e) {

            }

            public DomainInfo getDomain(WXPayConfig wxPayConfig) {
                return new DomainInfo("api.mch.weixin.qq.com",true);
            }
        };
    }
}
```

(3) 在订单服务项目`lkd_order_service`里添加微信支付服务接口的定义，并且实现该接口：

```java
package com.lkd.service;

/**
 * 微信支付服务接口
 */
public interface WXPayService {
    /**
     * 通过jsCode获取openId
     * @param jsCode
     * @return
     */
    String getOpenId(String jsCode);

    /**
     * 调用统一下单接口发起支付
     * @param openId
     * @param orderNo
     * @return
     */
    String requestPay(String openId,String orderNo);

    /**
     * 微信回调之后的处理
     * @param notifyResult
     * @throws Exception
     */
    void notify(String notifyResult) throws Exception;
}
```

```java
package com.lkd.service.impl;

import com.github.wxpay.sdk.WXPayRequest;
import com.github.wxpay.sdk.WXPayUtil;
import com.github.wxpay.sdk.WxPaySdkConfig;
import com.google.common.base.Strings;
import com.google.common.collect.Maps;
import com.lkd.common.VMSystem;
import com.lkd.conf.WXConfig;
import com.lkd.entity.OrderEntity;
import com.lkd.exception.LogicException;
import com.lkd.service.OrderService;
import com.lkd.service.WXPayService;
import com.lkd.utils.JsonUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.Map;

@Service
@Slf4j
public class WXPayServiceImpl implements WXPayService {
    @Autowired
    private WXConfig wxConfig;
    @Autowired
    private WxPaySdkConfig wxPaySdkConfig;
    @Autowired
    private OrderService orderService;

    @Override
    public String getOpenId(String jsCode) {
        String getOpenIdUrl = "https://api.weixin.qq.com/sns/jscode2session?appid="+wxConfig.getAppId()+"&secret="+wxConfig.getAppSecret()+"&js_code="+jsCode+"&grant_type=authorization_code";
        RestTemplate restTemplate = new RestTemplate();
        String respResult = restTemplate.getForObject(getOpenIdUrl,String.class);

        log.info("weixin pay result",respResult);
        if( Strings.isNullOrEmpty(respResult)) return "";
        try{
            String errorCode = JsonUtil.getValueByNodeName("errcode",respResult) ;
            if(errorCode != null){
                int errorCodeInt = Integer.valueOf(errorCode).intValue();
                if(errorCodeInt != 0) return "";
            }

            return JsonUtil.getValueByNodeName("openid",respResult);
        }catch (Exception ex){
            return "";
        }
    }

    @Override
    public String requestPay(String openId, String orderNo) {
        OrderEntity orderEntity = orderService.getByOrderNo(orderNo);
        try{
            String nonce_str = WXPayUtil.generateNonceStr();
            //1.封装请求参数
            Map<String,String> map= Maps.newHashMap();
            map.put("appid",wxPaySdkConfig.getAppID());//公众账号ID
            map.put("mch_id",wxPaySdkConfig.getMchID());//商户号
            map.put("nonce_str", nonce_str);//随机字符串
            map.put("body","餐掌柜点餐");//商品描述
            map.put("out_trade_no",orderNo);//订单号
            map.put("total_fee",orderEntity.getAmount()+"");//金额
            map.put("spbill_create_ip","127.0.0.1");//终端IP
            map.put("notify_url",wxConfig.getNotifyUrl());//回调地址
            map.put("trade_type","JSAPI");//交易类型
            map.put("openid",openId);
            String xmlParam  = WXPayUtil.generateSignedXml(map, wxPaySdkConfig.getKey());
            System.out.println("参数："+xmlParam);
            orderService.updateById(orderEntity);
            //2.发送请求
            WXPayRequest wxPayRequest=new WXPayRequest(wxPaySdkConfig);
            String xmlResult = wxPayRequest.requestWithCert("/pay/unifiedorder", null, xmlParam, false);
            //3.解析返回结果
            Map<String, String> mapResult = WXPayUtil.xmlToMap(xmlResult);
            //返回状态码
            String return_code = (String) mapResult.get("return_code");
            //返回给移动端需要的参数
            Map<String, String> response = Maps.newHashMap();
            if(return_code == "SUCCESS" || return_code.equals(return_code)){
                // 业务结果
                String prepay_id = (String) mapResult.get("prepay_id");//返回的预付单信息
                if(Strings.isNullOrEmpty(prepay_id)){
                    throw new LogicException("当前订单可能已经被支付");
                }
                response.put("appId",wxConfig.getAppId());
                response.put("package", "prepay_id=" + prepay_id);
                response.put("signType","MD5");
                response.put("nonceStr", WXPayUtil.generateNonceStr());

                Long timeStamp = System.currentTimeMillis() / 1000;
                response.put("timeStamp", timeStamp + "");//要将返回的时间戳转化成字符串，不然小程序端调用wx.requestPayment方法会报签名错误

                //再次签名，这个签名用于小程序端调用wx.requesetPayment方法
                String sign = WXPayUtil.generateSignature(response,wxConfig.getPartnerKey());
                response.put("paySign", sign);
                response.put("appId","");
                return JsonUtil.serialize(response);
            }else {
                return null;
            }
        }catch (Exception ex){
            return "";
        }
    }

    @Override
    public void notify(String notifyResult) throws Exception {
        //解析
        Map<String, String> map = WXPayUtil.xmlToMap( notifyResult );
        //验签
        boolean signatureValid = WXPayUtil.isSignatureValid(map, wxConfig.getPartnerKey());

        if(signatureValid){
            if("SUCCESS".equals(map.get("result_code"))){
                String orderNo = map.get("out_trade_no");
                OrderEntity orderEntity = orderService.getByOrderNo(orderNo);
                orderEntity.setStatus(VMSystem.ORDER_STATUS_PAYED);
                orderEntity.setPayStatus(VMSystem.PAY_STATUS_PAYED);
                orderService.updateById(orderEntity);
            }else {
                log.error("支付回调出错:"+notifyResult);
            }
        }else {
            log.error("支付回调验签失败:"+notifyResult);
        }
    }
}
```

在service_common中定义创建订单请求对象：

```java
package com.lkd.viewmodel;

import lombok.Data;

import java.io.Serializable;

@Data
public class CreateOrder implements Serializable {
    /**
     * 售货机编号
     */
    private String innerCode;
    /**
     * 用户openId
     */
    private String openId;
    /**
     * 商品Id
     */
    private String skuId;

    /**
     * 支付方式？？？
     */
    private String payType;
}
```

  OrderService新增方法定义 

```java
    /**
     * 微信小程序支付创建订单
     * @param createOrder
     * @return
     */
    OrderEntity createOrder(CreateOrder createOrder);
```

在订单服务实现类`OrderServiceImpl`中完成创建订单的逻辑

```java
    @Override
    public OrderEntity createOrder(CreateOrder createOrder) {
        VendingMachineViewModel vm = vmService.getVMInfo(createOrder.getInnerCode());
        SkuViewModel sku = vmService.getSku(createOrder.getInnerCode(),createOrder.getSkuId());
        OrderEntity orderEntity = new OrderEntity();
        orderEntity.setAddr(vm.getNodeAddr());
        orderEntity.setSkuId(sku.getSkuId());
        orderEntity.setSkuName(sku.getSkuName());
        orderEntity.setAmount(sku.getRealPrice());
        orderEntity.setBusinessId(vm.getBusinessId());
        orderEntity.setBusinessName(vm.getBusinessName());
        orderEntity.setInnerCode(createOrder.getInnerCode());
        orderEntity.setOpenId(createOrder.getOpenId());
        orderEntity.setPayStatus(VMSystem.PAY_STATUS_NOPAY);
        orderEntity.setOrderNo(createOrder.getInnerCode()+createOrder.getSkuId()+System.nanoTime());
        //微信支付
        orderEntity.setPayType("2");

        orderEntity.setStatus(VMSystem.ORDER_STATUS_CREATE);
        orderEntity.setOwnerId(vm.getOwnerId());

        //设置合作商账单分账金额
        PartnerViewModel partner = userService.getPartner(vm.getOwnerId());
        BigDecimal bg = new BigDecimal(sku.getRealPrice());
        //遵循四舍五入的规则
        int bill = bg.multiply(new BigDecimal(partner.getRatio())).divide(new BigDecimal(100),0,BigDecimal.ROUND_HALF_UP).intValue();
        orderEntity.setBill(bill);


        this.save(orderEntity);
        OrderCheck orderCheck = new OrderCheck();
        orderCheck.setOrderNo(orderEntity.getOrderNo());

        return orderEntity;
    }
```

(4) 在service_common项目中定义小程序端支付请求对象，并在订单服务`lkd_order_service`中实现微信支付下单的Controller给小程序微服务调用：

```java
package com.lkd.viewmodel;

import lombok.Data;

import java.io.Serializable;

/**
 * 小程序端支付请求对象
 */
@Data
public class RequestPay implements Serializable {
    /**
     * 售货机编号
     */
    private String innerCode;
    /**
     * 小程序端JsCode
     */
    private String jsCode;
    /**
     * 商品Id
     */
    private String skuId;
}
```

在`lkd_order_service`项目中添加微信支付下单controller实现，方便小程序微服务调用：

```java
package com.lkd.http.controller;

import com.lkd.entity.OrderEntity;
import com.lkd.service.OrderService;
import com.lkd.service.WXPayService;
import com.lkd.utils.ConvertUtils;
import com.lkd.viewmodel.CreateOrder;
import com.lkd.viewmodel.RequestPay;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@RestController
@RequestMapping("/wxpay")
@Slf4j
public class WxPayController {
    @Autowired
    private WXPayService wxPayService;
    @Autowired
    private OrderService orderService;
    /**
     * 微信小程序支付
     * @param requestPay
     * @return
     */
    @PostMapping("/requestPay")
    public String requestPay(@RequestBody RequestPay requestPay){
        String openId = wxPayService.getOpenId(requestPay.getJsCode());
        CreateOrder createOrder = new CreateOrder();
        createOrder.setInnerCode(requestPay.getInnerCode());
        createOrder.setOpenId(openId);
        createOrder.setSkuId(requestPay.getSkuId());
        OrderEntity orderEntity = orderService.createOrder(createOrder);

        return wxPayService.requestPay(openId,orderEntity.getOrderNo());
    }

    /**
     * 微信支付回调接口
     * @param request
     * @return
     */
    @RequestMapping("/payNotify")
    @ResponseBody
    public void payNotify(HttpServletRequest request, HttpServletResponse response){
        try {
            //输入流转换为xml字符串
            String xml = ConvertUtils.convertToString( request.getInputStream() );
            wxPayService.notify(xml);

            //给微信支付一个成功的响应
            response.setContentType("text/xml");
            String data = "<xml><return_code><![CDATA[SUCCESS]]></return_code><return_msg><![CDATA[OK]]></return_msg></xml>";
            response.getWriter().write(data);
        }catch (Exception e){
            log.error("支付回调处理失败",e);
        }
    }

    /**
     * 获取openId
     * @param jsCode
     * @return
     */
    @GetMapping("/openid/{jsCode}")
    public String getOpenid(@PathVariable String jsCode){
        return wxPayService.getOpenId(jsCode);
    }
}
```

(5) 在`service_common`项目中定义订单外部调用feign调用接口，之后在小程序端调用feign来完成支付

订单feign接口定义：

```java
package com.lkd.feignService;

import com.lkd.feignService.fallback.OrderServiceFallbackFactory;
import com.lkd.viewmodel.OrderViewModel;
import com.lkd.viewmodel.Pager;
import com.lkd.viewmodel.RequestPay;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

@FeignClient(value = "order-service",fallbackFactory = OrderServiceFallbackFactory.class)
public interface OrderService {
    @PostMapping("/wxpay/requestPay")
    String requestPay(@RequestBody RequestPay requestPay);

    @GetMapping("/wxpay/openid/{jsCode}")
    String getOpenid(@PathVariable String jsCode);

    @GetMapping("/order/search")
    Pager<OrderViewModel> search(
            @RequestParam(value = "pageIndex",required = false,defaultValue = "1") Integer pageIndex,
            @RequestParam(value = "pageSize",required = false,defaultValue = "10") Integer pageSize,
            @RequestParam(value = "orderNo",required = false,defaultValue = "") String orderNo,
            @RequestParam(value = "openId",required = false,defaultValue = "") String openId,
            @RequestParam(value = "startDate",required = false,defaultValue = "") String startDate,
            @RequestParam(value = "endDate",required = false,defaultValue = "") String endDate);
}
```

在`lkd_microapp`小程序项目中添加OrderController用来接收小程序端发来的获取openId的请求、下单请求、取消订单的请求：

```java
package com.lkd.http.controller;

import com.lkd.common.VMSystem;
import com.lkd.config.ConsulConfig;
import com.lkd.exception.LogicException;
import com.lkd.feignService.OrderService;
import com.lkd.redis.RedisUtils;
import com.lkd.utils.DistributedLock;
import com.lkd.viewmodel.OrderViewModel;
import com.lkd.viewmodel.Pager;
import com.lkd.viewmodel.RequestPay;
import org.elasticsearch.common.Strings;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/order")
public class OrderController {
    @Autowired
    private RedisUtils redisUtils;

    @Autowired
    private OrderService orderService;
    @Autowired
    private ConsulConfig consulConfig;

    /**
     * 小程序请求支付
     * @param requestPay
     * @return
     */
    @PostMapping("/requestPay")
    public String requestPay(@RequestBody RequestPay requestPay){
        //分布式锁，机器同一时间只能处理一次出货
        DistributedLock lock = new DistributedLock(
                consulConfig.getConsulRegisterHost(),
                consulConfig.getConsulRegisterPort());
        DistributedLock.LockContext lockContext = lock.getLock(requestPay.getInnerCode(),60);
        if(!lockContext.isGetLock()){
            throw new LogicException("机器出货中请稍后再试");
        }
        redisUtils.set(VMSystem.VM_LOCK_KEY_PREF+requestPay.getInnerCode(),lockContext.getSession(),60);
        String responseData = orderService.requestPay(requestPay);
        if(Strings.isNullOrEmpty(responseData)){
            lock.releaseLock(lockContext.getSession());
            throw new LogicException("微信支付接口调用失败");
        }

        return responseData;
    }

    /**
     * 获取openId
     * @param jsCode
     * @return
     */
    @GetMapping("/openid/{jsCode}")
    public String getOpenid(@PathVariable String jsCode){
        return orderService.getOpenid(jsCode);
    }

    /**
     * 订单搜索
     * @param pageIndex
     * @param pageSize
     * @param orderNo
     * @param openId
     * @param startDate
     * @param endDate
     * @return
     */
    @GetMapping("/search")
    public Pager<OrderViewModel> search(
            @RequestParam(value = "pageIndex",required = false,defaultValue = "1") Integer pageIndex,
            @RequestParam(value = "pageSize",required = false,defaultValue = "10") Integer pageSize,
            @RequestParam(value = "orderNo",required = false,defaultValue = "") String orderNo,
            @RequestParam(value = "openId",required = false,defaultValue = "") String openId,
            @RequestParam(value = "startDate",required = false,defaultValue = "") String startDate,
            @RequestParam(value = "endDate",required = false,defaultValue = "") String endDate){
        return orderService.search(pageIndex,pageSize,orderNo,openId,startDate,endDate);
    }

    /**
     * 取消订单
     * @param innerCode
     */
    @GetMapping("/cancel/{innerCode}")
    public void cancel(@PathVariable String innerCode){
        DistributedLock lock = new DistributedLock(
                consulConfig.getConsulRegisterHost(),
                consulConfig.getConsulRegisterPort());
        //解锁售货机
        lock.releaseLock(VMSystem.VM_LOCK_KEY_PREF+innerCode);
    }
}
```

说明：售货机支付出货和传统电商下单流程最大的区别是，售货机是具备实体的、独占式的。当售货机在处理一个用户的出货过程中，是不能同时处理另一个用户的出货的，并且同一时间只能处理一个商品的出货。所以在下单的接口里用分布式锁进行了排他处理，在用户并发请求下单时会请求分布式锁，只有获得锁的用户才会向微信支付平台发起支付请求，没有获得锁的用户会收到售货机忙碌的提示，这样可以避免引发用户支付完成拿不到商品退款的流程，提高了用户体验。

## 4. 超时订单处理解决方案

### 4.1 需求分析

我们得立可得智能售货机系统中，当用户在小程序中开启支付之后，因为各种不确定的原因未能完成最终的付款，也未点击关闭支付页面的按钮，此时如果程序不处理的话，该订单就永远处于未支付状态，像这样状态的订单显然是一种未结束的订单状态，系统需要将这类的订单在10分钟之后自动处理掉，将订单的状态置于无效状态。

### 4.2 实现思路

(1) 在订单服务中的创建订单方法里，订单创建完成后，将改订单的信息发送到EMQ里的延迟队列中，延迟处理时间为10分钟。

(2) 在订单服务里订阅延迟队列主题下的消息，在收到消息后检查该订单的状态，如果订单还处于创建状态，则将订单置于无效状态。

### 4.3 代码实现

(1) 在`service_common`项目中定义要放入延迟队列中的消息对象：

```java
package com.lkd.contract.server;

import com.lkd.contract.AbstractContract;
import lombok.Data;

import java.io.Serializable;

@Data
public class OrderCheck extends AbstractContract implements Serializable {
    public OrderCheck() {
        this.setMsgType("orderCheck");
    }
    private String orderNo;
}
```

(2) 在订单服务项目`lkd_order_service`中的订单服务实现类`OrderServiceImpl`中的创建订单方法中添加向延迟队列发送消息的代码，修改完之后的代码如下：

```java
    @Override
    public OrderEntity createOrder(CreateOrder createOrder) {
        VendingMachineViewModel vm = vmService.getVMInfo(createOrder.getInnerCode());
        SkuViewModel sku = vmService.getSku(createOrder.getInnerCode(),createOrder.getSkuId());
        OrderEntity orderEntity = new OrderEntity();
        orderEntity.setAddr(vm.getNodeAddr());
        orderEntity.setSkuId(sku.getSkuId());
        orderEntity.setSkuName(sku.getSkuName());
        orderEntity.setAmount(sku.getRealPrice());
        orderEntity.setBusinessId(vm.getBusinessId());
        orderEntity.setBusinessName(vm.getBusinessName());
        orderEntity.setInnerCode(createOrder.getInnerCode());
        orderEntity.setOpenId(createOrder.getOpenId());
        orderEntity.setPayStatus(VMSystem.PAY_STATUS_NOPAY);
        orderEntity.setOrderNo(createOrder.getInnerCode()+createOrder.getSkuId()+System.nanoTime());
        //微信支付
        orderEntity.setPayType(createOrder.getPayType());

        orderEntity.setStatus(VMSystem.ORDER_STATUS_CREATE);
        orderEntity.setOwnerId(vm.getOwnerId());

        //设置合作商账单分账金额
        PartnerViewModel partner = userService.getPartner(vm.getOwnerId());
        BigDecimal bg = new BigDecimal(sku.getRealPrice());
        //遵循四舍五入的规则
        int bill = bg.multiply(new BigDecimal(partner.getRatio())).divide(new BigDecimal(100),0,BigDecimal.ROUND_HALF_UP).intValue();
        orderEntity.setBill(bill);


        this.save(orderEntity);
      
        //将订单放到延迟队列中，10分钟后检查支付状态！！！！！！！！！！！！！！！！！！
        OrderCheck orderCheck = new OrderCheck();
        orderCheck.setOrderNo(orderEntity.getOrderNo());
       
        try {
            mqttProducer.send("$delayed/600/"+OrderConfig.ORDER_DELAY_CHECK_TOPIC,2,orderCheck);
        } catch (JsonProcessingException e) {
            log.error("send to emq error",e);
        }

        return orderEntity;
    }
```

(3) 在订单服务的配置中添加订阅该主题的配置如下：

```yaml
mqtt:
  client:
    username: admin
    password: public
    serverURI: tcp://172.17.0.231:1883
    clientId: monitor.user${random.int[1000,9999]}
    keepAliveInterval: 10
    connectionTimeout: 30
  producer:
    defaultQos: 2
    defaultRetained: false
    defaultTopic: topic/test1
  consumer:
    consumerTopics: $share/g1/order/delayCheck #延时检查订单状态的topic
```

(4) 在订单服务项目中实现接收到该消息的处理代码：

```java
package com.lkd.business;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.lkd.annotations.ProcessType;
import com.lkd.common.VMSystem;
import com.lkd.contract.server.OrderCheck;
import com.lkd.entity.OrderEntity;
import com.lkd.service.OrderService;
import com.lkd.utils.JsonUtil;
import org.elasticsearch.common.Strings;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
@ProcessType(value = "orderCheck")
public class OrderCheckHandler implements MsgHandler{
    @Autowired
    private OrderService orderService;
    @Override
    public void prosess(String jsonMsg) throws IOException {
        OrderCheck orderCheck = JsonUtil.getByJson(jsonMsg, OrderCheck.class);
        if(orderCheck == null || Strings.isNullOrEmpty(orderCheck.getOrderNo())) return;

        QueryWrapper<OrderEntity> qw = new QueryWrapper<>();
        qw
                .lambda()
                .eq(OrderEntity::getOrderNo,orderCheck.getOrderNo())
                .eq(OrderEntity::getStatus,VMSystem.ORDER_STATUS_CREATE);

        OrderEntity orderEntity = orderService.getOne(qw);
        if(orderEntity == null || orderEntity.getStatus() != VMSystem.ORDER_STATUS_CREATE) return;

        UpdateWrapper<OrderEntity> uw = new UpdateWrapper<>();
        uw
                .lambda()
                .eq(OrderEntity::getOrderNo,orderCheck.getOrderNo())
                .set(OrderEntity::getStatus, VMSystem.ORDER_STATUS_INVALID);
        orderService.update(uw);
    }
}
```

## 5. 订单数据同步解决方案

### 5.1 需求分析

随着售货机系统的运营时间累积、设备数量的增加、用户购买的数量也随之增长，订单数据如果长期存在mysql中，势必会造成订单表数据的急剧增长，影响后续的查询及检索效率，为了提高订单数据的查询检索效率，我们采用将订单数据同步到ElasticSearch中。

### 5.2 实现思路

我们采用logstash将订单表里的数据增量更新同步到ElasticSearch中。通过logstash的定期同步的功能来实现。

### 5.3 logstash 介绍

 Logstash是一个开源的服务器端数据处理管道，可以同时从多个数据源获取数据，并对其进行转换，然后将其发送到你最喜欢的“存储”（当然，我们最喜欢的是Elasticsearch）。

**输入：采集各种样式、大小和来源的数据**

数据往往以各种各样的形式，或分散或集中地存在于很多系统中。Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。

 **过滤器：实时解析和转换数据** 

 数据从源传输到存储库的过程中，Logstash 过滤器能够解析各个事件，识别已命名的字段以构建结构，并将它们转换成通用格式，以便更轻松、更快速地分析和实现商业价值。 

 **输出：选择你的存储，导出你的数据** 

尽管 Elasticsearch 是我们的首选输出方向，能够为我们的搜索和分析带来无限可能，但它并非唯一选择。

Logstash 提供众多输出选择，您可以将数据发送到您要指定的地方，并且能够灵活地解锁众多下游用例。



### 5.4 代码实现

(1) 编写logstash的pipeline文件，用来定期从mysql数据库表中根据最后更新日期列(update_time)来读取增量数据，然后将数据输出写入到ElasticSearch中

```
input {
 stdin { }
    jdbc {
    	#设置jdbc的数据库连接字符串
        jdbc_connection_string => "jdbc:mysql://172.17.0.87:3306/lkd_order?serverTimezone=Asia/Shanghai"
  		#设置数据库的用户名
        jdbc_user => "root"
 		#设置数据库的密码
        jdbc_password => "root123"
 		#设置数据程序的驱动jar包路径
        jdbc_driver_library => "/resource/mysql-connector-java-8.0.18.jar"
 		#设置驱动类
        jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
		#设置数据库的日期时间格式
        jdbc_default_timezone => "Asia/Shanghai"
		#设置记录上次的值
		record_last_run => "true"

        #使用其他字段追踪而不是时间
        use_column_value => true
        #追踪的字段
        tracking_column => "update_time"
        #追踪列的类型
        tracking_column_type => "timestamp"
		last_run_metadata_path => "/usr/share/logstash/last_values/order_info.txt"
		clean_run => "false"
        

        #开启分页查询
        jdbc_paging_enabled => true

        #分页大小
        jdbc_page_size => "5000"
        statement => "SELECT * FROM tb_order where update_time > :sql_last_value order by update_time asc"
        #设置运行周期
        schedule => "* * * * *"
    }
 }
  
 output {
     stdout {
     	#设置以json的格式输出
        codec => json_lines
    }
    #设置输出到elasticsearch
    elasticsearch {
        hosts => "172.17.0.87:9200"
        #输出到的索引
        index => "order"
        #索引文档的id取采集源中的id列的值
        document_id => "%{id}"
    }
}

#过滤器配置
filter {
  ruby { 
  	#转换timestamp字段加8小时，这样符合北京时间
    code => "event.set('timestamp', event.get('@timestamp').time.localtime + 8*60*60)" 
	   }
  ruby {
  	#转换timestamp字段加8小时，这样符合北京时间
	code => "event.set('@timestamp',event.get('timestamp'))"
  }
  ruby{
  	#转换update_time，这样符合北京时间。通过event.get取出字段update_time中的值加8小时，然后再通过event.set将得到的值设置回update_time字段
	code => "event.set('update_time',event.get('update_time').time.localtime + 8*60*60)"
  }
  ruby{
  	#转换create_time，这样符合北京时间
	code => "event.set('create_time',event.get('create_time').time.localtime + 8*60*60)"
  }
}
```

- input：数据的来源配置，这里是我们的订单表中的数据
- output：输出到的目标，这里是ElasticSearch
- filter：对每条数据的过滤处理，这里我们处理了`update_time`和`create_time`两列数据的值，因为logstash读取和存入ElasticSearch中的时间数据格式是UTC时间，比我们国内正常的时间少8小时，这里特殊处理了下。这里也可以不处理，在后续程序中处理也是一种实现方案。

(3) 编写ElasticSearch对应订单的mapping，put到ElasticSearch中

```json
PUT order
{
  "mappings": {
    "properties": {
      "sku_name": {
        "type": "keyword"
      },
      "region_name": {
        "type": "keyword"
      },
      "business_name": {
        "type": "keyword"
      },
      "inner_code": {
        "type": "keyword"
      },
      "node_name": {
        "type": "keyword"
      },
      "order_no": {
        "type": "keyword"
      },
      "third_no": {
        "type": "keyword"
      },
      "addr": {
        "type": "text"
      },
      "open_id": {
        "type": "keyword"
      },
      "pay_type": {
        "type": "keyword"
      }
    }
  }
}
```

(2) 然后在启动logstash中用命令行指定pipeline文件

```shell
bin/logstash -f /usr/share/logstash/pipeline/mysqltoes.conf
```

在logstash运行日志中，会发现每隔1分钟会同步订单表中的更新数据到ElasticSearch中。

## 6. 用户订单数据检索及聚合查询

### 6.1 需求分析

用户在微信小程序中能够根据日期范围检索查询历史订单。具体的实现效果如下：

![](images/1-6.png)

### 6.2 实现思路

我们需要在程序中从ElasticSearch中将用户的订单数据根据日期时间范围查询，并根据时间进行倒序排序，分页展示。

### 6.3 代码实现

(1) 在订单服务里添加elasticsearch-rest-high-level-client相关依赖，要和我们的ElasticSearch版本一样，这里我们使用的是7.7.1版本

```xml
<!--es相关依赖-->
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
    <version>7.7.1</version>
</dependency>
<dependency>
    <groupId>org.elasticsearch</groupId>
    <artifactId>elasticsearch</artifactId>
    <version>7.7.1</version>
</dependency>
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-client</artifactId>
    <version>7.7.1</version>
</dependency>
<!--es相关依赖结束-->
```

(2) 在consul配置中心里修改订单服务的配置，在spring节点下添加elasticsearch的配置：

```Yaml
  elasticsearch:
    rest:
      uris: http://192.168.200.128:9200
```

(3) 在订单服务项目`lkd_order_service`中，修改订单服务接口`OrderService`，添加搜索订单的方法：

```java
    /**
     * 查询订单
     * @param pageIndex
     * @param pageSize
     * @return
     */
    Pager<OrderViewModel> search(Integer pageIndex, Integer pageSize, String orderNo, String openId, String startDate, String endDate);
```

并在实现类中实现该接口：

```java
@Autowired
private RestHighLevelClient client;

@Override
public Pager<OrderViewModel> search(Integer pageIndex, Integer pageSize, String orderNo, String openId, String startDate, String endDate) {
    SearchRequest searchRequest = new SearchRequest("order");
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();

    //根据订单号查询
    if(!Strings.isNullOrEmpty(orderNo)){
        boolQueryBuilder.must(QueryBuilders.termQuery("order_no",orderNo));
    }
    //根据openIdc查询
    if(!Strings.isNullOrEmpty(openId)){
        boolQueryBuilder.must(QueryBuilders.termQuery("open_id",openId));
    }
    //根据时间范围查询
    if(!Strings.isNullOrEmpty(startDate) && !Strings.isNullOrEmpty(endDate)){
        RangeQueryBuilder rangeQueryBuilder = QueryBuilders.rangeQuery("update_time");
        rangeQueryBuilder.gte(startDate);
        rangeQueryBuilder.lte(endDate);
        boolQueryBuilder.must(rangeQueryBuilder);
    }
    //按照最后更新时间由近到远的排序规则排序
    sourceBuilder.from((pageIndex -1)*pageSize);
    sourceBuilder.size(pageSize);
    sourceBuilder.sort("update_time", SortOrder.DESC);
    sourceBuilder.trackTotalHits(true);
    sourceBuilder.query(boolQueryBuilder);
    searchRequest.source(sourceBuilder);
    try {
        SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
        SearchHits hits = searchResponse.getHits();
        SearchHit[] searchHits = hits.getHits();
        List<OrderViewModel> orderList = Lists.newArrayList();
        for(SearchHit hit : searchHits){
            String hitResult = hit.getSourceAsString();
            OrderViewModel order = new OrderViewModel();
            JsonNode jsonNode = JsonUtil.getTreeNode(hitResult);
            order.setId(jsonNode.findPath("id").asLong());
            order.setStatus(jsonNode.findPath("status").asInt());
            order.setBill(jsonNode.findPath("bill").asInt());
            order.setOwnerId(jsonNode.findPath("owner_id").asInt());
            order.setPayType(jsonNode.findPath("pay_type").asText());
            order.setOrderNo(jsonNode.findPath("order_no").asText());
            order.setInnerCode(jsonNode.findPath("inner_code").asText());
            order.setSkuName(jsonNode.findPath("sku_name").asText());
            order.setSkuId(jsonNode.findPath("sku_id").asLong());
            order.setPayStatus(jsonNode.findPath("pay_status").asInt());
            order.setBusinessName(jsonNode.findPath("business_name").asText());
            order.setBusinessId(jsonNode.findPath("business_id").asInt());
            order.setRegionId(jsonNode.findPath("region_id").asLong());
            order.setRegionName(jsonNode.findPath("region_name").asText());
            order.setPrice(jsonNode.findPath("price").asInt());
            order.setAmount(jsonNode.findPath("amount").asInt());
            order.setAddr(jsonNode.findPath("addr").asText());
            order.setOpenId(jsonNode.findPath("open_id").asText());
            order.setCreateTime(LocalDateTime.parse(jsonNode.findPath("create_time").asText(),DateTimeFormatter.ISO_DATE_TIME));
            order.setUpdateTime(LocalDateTime.parse(jsonNode.findPath("update_time").asText(),DateTimeFormatter.ISO_DATE_TIME));
            orderList.add(order);
        }
        Pager<OrderViewModel> pager = new Pager<>();
        pager.setTotalCount(searchResponse.getHits().getTotalHits().value);

        pager.setPageSize(searchResponse.getHits().getHits().length);
        pager.setCurrentPageRecords(orderList);
        pager.setPageIndex(pageIndex);

        return pager;
    } catch (IOException e) {
        log.error("查询es失败",e);

        return Pager.buildEmpty();
    }
}
```

(4)在订单服务的`OrderController`中添加Rest接口调用服务层方法将数据返回

```java
@GetMapping("/search")
public Pager<OrderViewModel> search(
    @RequestParam(value = "pageIndex",required = false,defaultValue = "1") Integer pageIndex,
    @RequestParam(value = "pageSize",required = false,defaultValue = "10") Integer pageSize,
    @RequestParam(value = "orderNo",required = false,defaultValue = "") String orderNo,
    @RequestParam(value = "openId",required = false,defaultValue = "") String openId,
    @RequestParam(value = "startDate",required = false,defaultValue = "") String startDate,
    @RequestParam(value = "endDate",required = false,defaultValue = "") String endDate){
    return orderService.search(pageIndex,pageSize,orderNo,openId,startDate,endDate);
}
```

(5) 在service_common项目中修改订单服务的feign接口`OrderService`，添加查询订单的方法：

```java
@GetMapping("/order/search")
Pager<OrderViewModel> search(
    @RequestParam(value = "pageIndex",required = false,defaultValue = "1") Integer pageIndex,
    @RequestParam(value = "pageSize",required = false,defaultValue = "10") Integer pageSize,
    @RequestParam(value = "orderNo",required = false,defaultValue = "") String orderNo,
    @RequestParam(value = "openId",required = false,defaultValue = "") String openId,
    @RequestParam(value = "startDate",required = false,defaultValue = "") String startDate,
    @RequestParam(value = "endDate",required = false,defaultValue = "") String endDate);
```

(6) 在小程序项目`lkd_microapp`中的`OrderController`中，添加搜索订单的方法，将调用feign接口订单数据返回：

```java
/**
     * 订单搜索
     * @param pageIndex
     * @param pageSize
     * @param orderNo
     * @param openId
     * @param startDate
     * @param endDate
     * @return
     */
@GetMapping("/search")
public Pager<OrderViewModel> search(
    @RequestParam(value = "pageIndex",required = false,defaultValue = "1") Integer pageIndex,
    @RequestParam(value = "pageSize",required = false,defaultValue = "10") Integer pageSize,
    @RequestParam(value = "orderNo",required = false,defaultValue = "") String orderNo,
    @RequestParam(value = "openId",required = false,defaultValue = "") String openId,
    @RequestParam(value = "startDate",required = false,defaultValue = "") String startDate,
    @RequestParam(value = "endDate",required = false,defaultValue = "") String endDate){
    return orderService.search(pageIndex,pageSize,orderNo,openId,startDate,endDate);
}
```





## 1. 小程序端售货机搜索

### 1.1 需求分析

我们面向用户的客户端是基于微信小程序来实现的，用户打开小程序进入首页之后有两个购物入口：

- 直接扫码

  用户就站在售货机旁边并且已经在售货机上选择了商品，此时在售货机商品详情页上会展示一个支付二维码，用户扫码之后会进入微信付款流程，从而进入购物流程

- 搜索附近售货机

  用户不在售货机旁边，但是知道我们的售货机产品，曾经使用过我们的小程序，对购物流程比较了解。当用户打开小程序，在小程序首页会有搜索附近售货机的选项，此时用户选择该选项，小程序会获取用户所在位置的经纬度地理位置信息，将该信息传入小程序服务端接口，服务端根据传入的信息进行搜索，如果在距离范围内可以搜索到设备会将展示在小程序内置的地图上，同时会按照由近到远的顺序展示多个售货机列表。

搜索附近售货机的作用主要是用来增加用户的复购率，提高用户的购物体验，让用户方便的找到我们的售货机。

具体的业务产品原型如下：

小程序首页

![](images\1-1.png)

附近售货机搜索结果

![](images/1-2.png)

当用户搜索选择指定的设备点击去看看之后应在小程序端呼出相应地图软件并导航到售货机所在位置，具体效果如下：

![](images/1-5.png)

### 1.2 实现思路

（1）在小程序端定义售货机搜索服务接口，该接口需要传入用户所在位置的经纬度数据和要搜索的半径距离

（2）服务实现实现该接口，根据用户传入的数据从ES中按照距离由远到近的排序方式查询售货机列表

（3）在小程序端定义Controller接口调用实现的接口，将结果返回给前端

### 1.3 代码实现

#### 1.3.1 售货机坐标保存

提供的虚拟机镜像中也提供了elasticsearch和kibana的环境

![](images/5-1.png)

目前售货机微服务已经添加了ElasticSearch的依赖

```xml
<!--es相关依赖-->
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
    <version>7.7.1</version>
</dependency>
<dependency>
    <groupId>org.elasticsearch</groupId>
    <artifactId>elasticsearch</artifactId>
    <version>7.7.1</version>
</dependency>
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-client</artifactId>
    <version>7.7.1</version>
</dependency>
<!--es相关依赖结束-->
```

配置中心中也有了elasticsearch的配置

```yaml
  elasticsearch:
    rest:
      uris: http://192.168.200.128:9200
```



#### 1.3.2 搜索附近售货机

（1）在`lkd_microapp`项目中定义根据位置信息搜索需要传入的参数对象

```java
package com.lkd.http.viewModel;

import lombok.Data;

import java.io.Serializable;

@Data
public class VmSearch implements Serializable {
    /**
     * 纬度
     */
    private Double lat;
    /**
     * 经度
     */
    private Double lon;
    /**
     * 搜索半径
     */
    private Integer distance;
}
```

（2）在`service_common`项目中的`dto`包下定义需要返回的售货机信息对象

```java
package com.lkd.dto;

import lombok.Data;

import java.io.Serializable;

/**
 * 售货机在es中存储的信息
 */
@Data
public class VmInfoDTO implements Serializable {
    /**
     * 售货机经纬度信息
     */
    private String location;
    /**
     * 售货机编号
     */
    private String innerCode;
    /**
     * 点位名称
     */
    private String nodeName;
    /**
     * 详细地址
     */
    private String addr;
    /**
     * 距离(单位：米)
     */
    private Integer distance;
}
```

（3）在`lkd_microapp`项目中定义搜索售货机的接口

```java
package com.lkd.service;

import com.lkd.dto.VmInfoDTO;
import com.lkd.http.viewModel.VmSearch;
import com.lkd.viewmodel.Pager;

import java.util.List;

/**
 * 售货机基础信息接口
 */
public interface VMInfoService {
    /**
     * 根据条件搜索售货机
     * @param searchReq
   @return
     */
    List<VmInfoDTO> search(VmSearch searchReq);
}
```

编写实现类

```java
package com.lkd.service.impl;

import com.google.common.collect.Lists;
import com.lkd.dto.VmInfoDTO;
import com.lkd.http.viewModel.VmSearch;
import com.lkd.service.VMInfoService;
import com.lkd.utils.JsonUtil;
import lombok.extern.slf4j.Slf4j;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.geo.GeoDistance;
import org.elasticsearch.common.unit.DistanceUnit;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.GeoDistanceQueryBuilder;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.sort.GeoDistanceSortBuilder;
import org.elasticsearch.search.sort.SortOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;

@Service
@Slf4j
public class VMInfoServiceImpl implements VMInfoService {
    @Autowired
    private RestHighLevelClient client;
    @Override
    public List<VmInfoDTO> search(VmSearch searchReq) {
        //指定索引
        SearchRequest searchRequest = new SearchRequest("vm");
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();

        //从近到远排序规则构建
        GeoDistanceSortBuilder distanceSortBuilder = new GeoDistanceSortBuilder("location",searchReq.getLat(),searchReq.getLon());
        distanceSortBuilder.unit(DistanceUnit.KILOMETERS);
        distanceSortBuilder.order(SortOrder.ASC);
        distanceSortBuilder.geoDistance(GeoDistance.ARC);

        //中心点及半径构建
        GeoDistanceQueryBuilder geoDistanceQueryBuilder = new GeoDistanceQueryBuilder("location");
        geoDistanceQueryBuilder.distance(searchReq.getDistance(), DistanceUnit.KILOMETERS);
        geoDistanceQueryBuilder.point(searchReq.getLat(),searchReq.getLon());

        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();

        boolQueryBuilder.must(geoDistanceQueryBuilder);

        searchSourceBuilder.query(boolQueryBuilder);

        searchSourceBuilder.sort(distanceSortBuilder);

        searchRequest.source(searchSourceBuilder);
        try {
            SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);
            SearchHits hits = searchResponse.getHits();
            if(hits.getTotalHits().value <= 0){
                return Lists.newArrayList();
            }
            List<VmInfoDTO> vmInfoList = Lists.newArrayList();
            Arrays.stream(hits.getHits()).forEach(h->{
                VmInfoDTO vmInfo = null;
                try {
                    vmInfo = JsonUtil.getByJson(h.getSourceAsString(), VmInfoDTO.class);
                    //将千米转换为米
                    BigDecimal geoDis=new BigDecimal((double)h.getSortValues()[0]*1000);
                    vmInfo.setDistance(geoDis.intValue());
                } catch (IOException e) {
                    log.error("convert vminfo error",e);
                }
                vmInfoList.add(vmInfo);
            });

            return vmInfoList;
        } catch (IOException e) {
            log.error("search location error",e);

            return Lists.newArrayList();
        }
    }
}
```

(4) 在`lkd_microapp`项目中编写售货机逻辑相关的Controller，调用搜索服务将结果返回给前端

```java
package com.lkd.http.controller;
import com.lkd.feignService.VMService;
import com.lkd.dto.VmInfoDTO;
import com.lkd.http.viewModel.SkuInfoViewModel;
import com.lkd.http.viewModel.VmSearch;
import com.lkd.service.VMInfoService;
import com.lkd.viewmodel.SkuViewModel;
import com.lkd.viewmodel.VendingMachineViewModel;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;
@RestController
@RequestMapping("/vm")
public class VMController {
    @Autowired
    private VMInfoService vmInfoService;

    /**
     * 搜索附近售货机
     * @param vmSearch
     * @return
     */
    @PostMapping("/search")
    public List<VmInfoDTO> search(@RequestBody VmSearch vmSearch){
        return vmInfoService.search(vmSearch);
    }
}
```