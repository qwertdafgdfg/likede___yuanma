# 第5章 GPS采集搜索与数据透传

## 1. 设备GPS信息采集

### 1.1 ElasticSearch中地理位置信息的概念

#### 1.1.1 地理位置坐标点

**地理坐标点** 是指地球表面可以用经纬度描述的一个点。 地理坐标点可以用来计算两个坐标间的距离，还可以判断一个坐标是否在一个区域中，或在聚合中。

地理坐标点不能被动态映射自动检测，需要显式声明对应字段类型为 `geo-point` ：

在ES下创建索引及字段映射

```http
PUT /gps
{
  "mappings": {
	 "properties": {
		"location": {
		  "type": "geo_point"
		}
	 }
  }
}
```

需要显示指定location的类型为`geo_point`。

#### 1.1.2 经纬度坐标格式 

经纬度在ElasticSearch中的保存时的形式可以是字符串、数组或者对象。

```json
PUT /gps/1
{
  "location": "40.715, -74.011" 
}

PUT /gps/2
{
  "location": { 
    "lat":     40.722,
    "lon":    -73.989
  }
}

PUT /gps/3
{
  "location": [ -73.983, 40.719 ] 
}
```

- 字符串形式以半角逗号分割，如 `"lat,lon"` 
- 对象形式显式命名为 `lat` 和 `lon` 
- 数组形式表示为 `[lon,lat]` 

可能所有人都至少一次踩过这个坑：地理坐标点用字符串形式表示时是纬度在前，经度在后（ `"latitude,longitude"` ），而数组形式表示时是经度在前，纬度在后（ `[longitude,latitude]` ）—顺序刚好相反。

其实，在 Elasticesearch 内部，不管字符串形式还是数组形式，都是经度在前，纬度在后。不过早期为了适配 GeoJSON 的格式规范，调整了数组形式的表示方式。因此，在使用地理位置的路上就出现了这么一个“捕熊器”，专坑那些不了解这个陷阱的使用者。

#### 1.1.3 地理位置过滤器

地理距离过滤器（ `geo_distance` ）以给定位置为圆心画一个圆，来找出那些地理坐标落在其中的文档： 

```json
GET gps/_search
{
  "query": {
    "geo_distance": {
      "distance": "1km", 
      "location": { 
        "lat": 43.870882,
        "lon": 87.560653
      }
    }
  }
}
```

- "distance": "1km"： 找出所有与指定点距离在 `1km` 内的 `location` 字段
- 中心点可以表示为字符串，数组或者（如示例中的）对象 

### 1.2 需求分析 

我们需要将设备上报上来的gps指标信息存储到Elasticsearch中。

### 1.3 实现思路 

（1）通过解析设备报文解析判断是否是gps指标数据

（2）如果是gps指标数据那么将该数据存储到Elasticsearch中

### 1.4 代码实现 

#### 1.4.1 GPS主题订阅 

（1）修改GpsServiceImpl的update方法，在用户修改gps定义时重新订阅主题

```java
@Autowired
private EmqClient emqClient;

@Override
public boolean update(GPSEntity gpsEntity) {
    //订阅主题
    try {
        emqClient.subscribe(gpsEntity.getSubject());
    } catch (MqttException e) {
        log.error("subscribe error",e);
    }
    gpsEntity.setId(1);
    return this.updateById(gpsEntity);
}
```

（2）修改EmqMsgProcess的autoSub方法，订阅GPS主题

```java
@Autowired
private GpsService gpsService;

/**
 * 自动订阅主题
 */
private void autoSub(){
    quotaService
        .getAllSubject()
        .forEach(s->{
            try {
                //通过共享订阅以免影响其他系统接收消息，并且可以通过负载均衡实现消息的接收处理，以免客户端发过来的消息频率过大，服务端被击垮
                emqClient.subscribe("$queue/"+s);
                System.out.println("订阅主题："+s);
            } catch (MqttException e) {
                log.error("订阅主题出错："+ s,e);
            }
        });

    //----------------订阅gps主题数据-------------------
    GPSEntity gpsEntity = gpsService.getGps();
    if(gpsEntity == null) return;
    try {
        if(Strings.isNotEmpty(gpsEntity.getSubject())){  //如果主题不为空
            emqClient.subscribe("$queue/"+gpsEntity.getSubject());  
        }
    } catch (MqttException e) {
        log.error("订阅主题出错：",e);
    }
    
}
```

#### 1.4.2 GPS数据采集与存储 

（1）定义DTO

```java
package com.yikekong.dto;

import lombok.Data;

import java.io.Serializable;

@Data
public class DeviceLocation implements Serializable{
    private String deviceId;
    private String location;
}
```

（2）ESRepository新增方法用于存储设备的gps

```java
/**
 * 更新设备gps信息
 * @param deviceLocation
 */
public void saveLocation(DeviceLocation deviceLocation){
    try{
        IndexRequest request = new IndexRequest("gps");
        request.source("location",deviceLocation.getLocation());
        request.id(deviceLocation.getDeviceId());
        client.index(request,RequestOptions.DEFAULT);
    }catch (Exception e){
        log.error("update es error",e);
    }
}
```

（2）GpsService新增方法定义，用于解析报文

```java
/**
 * 解析报文获得GPS信息
 * @param payloadMap 报文内容
 * @return gps
 */
DeviceLocation analysis(String topic, Map<String, Object> payloadMap);
```

GpsServiceImpl实现该方法

```java
@Override
public DeviceLocation analysis(String topic, Map<String, Object> payloadMap) {
    //读取规则
    GPSEntity gpsEntity = getGps();
    if(gpsEntity == null) return null;
    if(Strings.isNullOrEmpty(gpsEntity.getSubject())) return null;// 主题为空
    if(!topic.equals(gpsEntity.getSubject()))  return null;//如果主题不匹配

    //读取设备id
    String deviceId = "";
    deviceId = (String) payloadMap.get(gpsEntity.getSnKey());
    if(Strings.isNullOrEmpty(deviceId)) return null;

    //提取gps
    String location = "";
    if(gpsEntity.getSingleField()){ //如果是单字段
        location = ((String) payloadMap.get(gpsEntity.getValueKey())).replace(gpsEntity.getSeparation(),",");
    }else { //如果是双字段
        location = payloadMap.get(gpsEntity.getLongitude()) + "," +  payloadMap.get(gpsEntity.getLatitude());
    }
    
    //封装返回结果
    if(location!=null){
        DeviceLocation deviceLocation=new DeviceLocation();
        deviceLocation.setDeviceId(deviceId);
        deviceLocation.setLocation(location);
        return deviceLocation;
    }else{
        return  null;
    }
}
```

（3）修改EmqMsgProcess的messageArrived方法，添加处理gps数据的方法

```java
@Override
public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
    String payload = new String(mqttMessage.getPayload());
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> payloadMap = mapper.readValue(payload, Map.class);
    System.out.println("接收到数据："+payloadMap);
    //解析数据
    DeviceInfoDTO deviceInfoDTO = quotaService.analysis(topic, payloadMap);
    if(deviceInfoDTO!=null){
        //告警判断
        deviceInfoDTO= alarmService.verifyDeviceInfo(deviceInfoDTO);  //返回包含了告警判断的对象
        //保存设备信息
        deviceService.saveDeviceInfo(deviceInfoDTO.getDevice());
        //保存指标数据
        quotaService.saveQuotaToInflux(deviceInfoDTO.getQuotaList());
    }

    //处理gps数据
    DeviceLocation deviceLocation = gpsService.analysis(topic, payloadMap);//解析
    if(deviceLocation!=null){
        esRepository.saveLocation(deviceLocation);
    }
}
```

（4）测试验证

将亿可控项目代码运行起来，通过EMQ测试客户端向geo主题下发送一条数据，具体的数据内容如下：

```json
{
    "lat": 87.560653,
    "lon": 43.870882,
    "deviceSn": "123456"
}
```

此时我们查询下es检查数据是否正确被存储进去了，运行查询发现数据已经进去了：

![](images/5-2.png)



## 2. 获取设备详情

（2）定义封装设备详情的DTO

```java
package com.yikekong.dto;

import lombok.Data;

import java.io.Serializable;
import java.util.List;

/**
 * 设备详情
 */
@Data
public class DeviceInfo implements Serializable {
    private List<QuotaInfo> quotaInfo;
    private String deviceId;
    private Boolean isOnline;
    private String location;
}
```

（3）DeviceController新增方法

```java
/**
 * 获取设备详情
 * @param deviceId
 * @return
 */
@GetMapping("/deviceInfo/{deviceId}")
public DeviceInfo getDeviceInfo(@PathVariable String deviceId){
    List<QuotaInfo> quotaResults = quotaService.getDeviceQuotaList(deviceId);
    String location = esRepository.getDeviceLocation(deviceId);
    DeviceDTO deviceStatus = esRepository.searchDeviceById(deviceId);
    DeviceInfo deviceInfo = new DeviceInfo();
    deviceInfo.setDeviceId(deviceId);
    deviceInfo.setIsOnline(deviceStatus.getOnline());
    deviceInfo.setQuotaInfo(quotaResults);
    deviceInfo.setLocation(location);

    return deviceInfo;
}
```



## 2. 设备GPS位置搜索

### 2.1 需求分析 

系统要在首页展示出设备的分布情况，点击每个设备要显示的状态和指标详情。具体效果如下：

![](images/5-3.png)

### 2.2 实现思路  

（1）在Elasticsearch通信类里实现根据坐标点及公里范围半径查询设备列表的方法

（2） 在服务层接收坐标点和公里范围参数，将这些参数传入Elasticsearch通信类查询设备位置信息列表，然后再根据所查询出的设备列表从InfluxDB中查询出该设备所有指标数据进行组合将结果返回

（3） 通过定义前端Controller接口接收一个经纬度坐标点和一个公里为单位的距离，通过调用服务层接口返回设备状态信息及坐标信息列表。

### 2.3 代码实现 

（1）在`ESRepository`中实现根据坐标点及半径距离查询设备位置的方法：

```java
/**
     * 搜索一定距离之内的设备
     * @param distance 距离坐标点半径
     * @return
     */
public List<DeviceLocation> searchDeviceLocation(Double lat,Double lon,Integer distance){
    SearchRequest searchRequest = new SearchRequest("gps");
    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();

    //从近到远排序规则构建
    GeoDistanceSortBuilder distanceSortBuilder = new GeoDistanceSortBuilder("location",lat,lon);
    distanceSortBuilder.unit(DistanceUnit.KILOMETERS);
    distanceSortBuilder.order(SortOrder.ASC);
    distanceSortBuilder.geoDistance(GeoDistance.ARC);

    //中心点及半径构建
    GeoDistanceQueryBuilder geoDistanceQueryBuilder = new GeoDistanceQueryBuilder("location");
    geoDistanceQueryBuilder.distance(distance, DistanceUnit.KILOMETERS);
    geoDistanceQueryBuilder.point(lat,lon);

    BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();

    boolQueryBuilder.must(geoDistanceQueryBuilder);

    searchSourceBuilder.query(boolQueryBuilder);

    searchSourceBuilder.sort(distanceSortBuilder);
    //只取前200个
    searchSourceBuilder.from(0);
    searchSourceBuilder.size(200);
    searchRequest.source(searchSourceBuilder);

    try {
        SearchResponse searchResponse = client.search(searchRequest,RequestOptions.DEFAULT);
        SearchHits hits = searchResponse.getHits();
        if(hits.getTotalHits().value <= 0){
            return Lists.newArrayList();
        }
        List<DeviceLocation> deviceLocationList = Lists.newArrayList();
        Arrays.stream(hits.getHits()).forEach(h->{
            DeviceLocation deviceLocation = new DeviceLocation();
            deviceLocation.setDeviceId(h.getId());
            deviceLocation.setLocation(h.getSourceAsMap().get("location").toString());
            deviceLocationList.add(deviceLocation);
        });

        return deviceLocationList;
    } catch (IOException e) {
        log.error("search location error",e);

        return Lists.newArrayList();
    }
}
```

（2）定义一个带有设备全部状态和指标的DTO对象：

```java
package com.yikekong.dto;
import lombok.Data;
import java.io.Serializable;
import java.util.List;

@Data
public class DeviceFullInfo implements Serializable{
    private List<QuotaInfo> quotaList;
    private String location;
    private String deviceId;
    private Boolean online;
}
```

（3）在GpsService服务接口中定义通过经纬度坐标和距离半径获取设备全部信息列表的方法

```java
/**
* 根据经纬度获取一定范围内的设备信息
* @param lat
* @param lon
* @param distance
* @return
*/
List<DeviceFullInfo> getDeviceFullInfo(Double lat,Double lon,Integer distance);
```

在GpsServiceImpl实现类中实现该方法

```java
@Autowired
private ESRepository esRepository;

@Autowired
private QuotaService quotaService;

@Override
public List<DeviceFullInfo> getDeviceFullInfo(Double lat, Double lon, Integer distance) {
    //通过坐标点和半径查询设备坐标列表
    List<DeviceLocation> deviceLocations = esRepository.searchDeviceLocation(lat,lon,distance);
    List<DeviceFullInfo> deviceFullInfos = Lists.newArrayList();
    deviceLocations.forEach(d->{
        DeviceFullInfo deviceFullInfo = new DeviceFullInfo();
        deviceFullInfo.setLocation(d.getLocation());
        deviceFullInfo.setDeviceId(d.getDeviceId());
        //获取和设置设备在线状态信息
        DeviceDTO deviceDTO = esRepository.searchDeviceById(d.getDeviceId());
        if(deviceDTO == null){
            deviceFullInfo.setOnline(false);
        }else {
            deviceFullInfo.setOnline(deviceDTO.getOnline());
        }
        //查询和设置设备所有指标的最新值
        deviceFullInfo.setQuotaList(quotaService.getDeviceQuotaList(d.getDeviceId()));
        deviceFullInfos.add(deviceFullInfo);
    });

    return deviceFullInfos;
}
```

（4）在GpsController中定义前端接口方法通过查询将结果返回

```java
    /**
     * 根据经纬度获取设备信息
     * @param lat
     * @param lon
     * @param distance
     * @return
     */
    @GetMapping("/deviceList/{lat}/{lon}/{distance}")
    public List<DeviceFullInfo> getDeviceFullInfo(
            @PathVariable Double lat, 
            @PathVariable Double lon, 
            @PathVariable Integer distance){
        return gpsService.getDeviceFullInfo(lat,lon,distance);
    }
```

（5）测试

用我们在上一节中的设备编号为`123456`向InfluxDB中插入3条指标数据，插入完成后如下：

![](images/5-4.png)

将项目运营起来，通过浏览器调用controller接口可以看到数据的返回

![](images/5-5.png)



## 3. 数据透传

### 3.1 需求分析

作为一个物联网数据中台，亿可控系统需要将解析过来的指标数据以及报警数据透传给其它的业务系统。所谓透传，就是信息发送到配置好的webhook（外部业务系统的url）。这里包括两部分：

（1）指标的数据透传

将解析的指标直接透传给其它业务系统

（2）告警的数据透传

告警有一个沉默周期的设置。例如沉默周期设置为5分钟。那么5分钟内不会为同一个指标的同一种告警进行重复告警，超过5分钟才会再次告警。

### 3.2 实现思路

我们可以分为三步骤来实现数据透传

（1）编写通用的数据透传工具类

（2）直接将解析后的指标数据利用透传工具进行透传。

（3）编写数据告警透传逻辑。利用redis的过期时间来实现沉默周期告警逻辑。

### 3.3 代码实现

#### 3.3.1 数据透传工具类

创建HttpUtil类用于数据透传

```java
package com.yikekong.util;
import lombok.extern.slf4j.Slf4j;
import org.elasticsearch.common.Strings;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.client.RestTemplate;

@Slf4j
public class HttpUtil{
    public static void httpPost(String url,Object msg){
        if(Strings.isNullOrEmpty(url)) return;
        new Thread(()->{
            RestTemplate restTemplate = new RestTemplateBuilder()
                    .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                    .build();
            try {
                restTemplate.postForObject(url,msg,String.class);
            }catch (Exception e){
                log.error("post alarm msg error",e);
            }
        }).start();
    }
}
```

#### 3.3.2 指标数据透传

（1）创建NoticeService接口，并定义方法

```java
package com.yikekong.service;

import com.yikekong.dto.QuotaDTO;

import java.util.List;

/**
 * 通知(透传)服务
 */
public interface NoticeService {

    /**
     * 指标数据透传
     * @param quotaDTOList
     */
    void quotaTransfer(List<QuotaDTO> quotaDTOList);
}
```

创建NoticeServiceImpl 并实现方法

```java
    @Override
    public void quotaTransfer(List<QuotaDTO> quotaDTOList) {
        for( QuotaDTO quotaDTO:quotaDTOList ){
            if(!Strings.isNullOrEmpty(quotaDTO.getWebhook())){  //如果钩子非空，则做数据透传
                HttpUtil.httpPost(quotaDTO.getWebhook(),quotaDTO);
            }
        }
    }
```

（2）修改EmqMsgProcess的messageArrived方法，添加调用指标透传的方法

```java
@Autowired
private QuotaService quotaService;

@Override
public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
    String payload = new String(mqttMessage.getPayload());
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> payloadMap = mapper.readValue(payload, Map.class);
    System.out.println("接收到数据："+payloadMap);
    //解析数据
    DeviceInfoDTO deviceInfoDTO = quotaService.analysis(topic, payloadMap);
    if(deviceInfoDTO!=null){
        //告警判断
        deviceInfoDTO= alarmService.verifyDeviceInfo(deviceInfoDTO);  //返回包含了告警判断的对象
        //保存设备信息
        deviceService.saveDeviceInfo(deviceInfoDTO.getDevice());
        //保存指标数据
        quotaService.saveQuotaToInflux(deviceInfoDTO.getQuotaList());

        //---------指标数据透传----------------------
        noticeService.quotaTransfer(deviceInfoDTO.getQuotaList());
        //------------------------------------------

    }

    //处理gps数据
    DeviceLocation deviceLocation = gpsService.analysis(topic, payloadMap);//解析
    if(deviceLocation!=null){
        esRepository.saveLocation(deviceLocation);
    }

}
```

#### 3.3.3 告警数据透传

（1）创建DTO用于封装告警信息

```java
package com.yikekong.dto;

import lombok.Data;

import java.io.Serializable;

/**
 * 告警信息封装类
 */
@Data
public class AlarmMsg implements Serializable{
    private String deviceId;//设备id
    private String alarmName;//告警名称
    private String quotaName;//指标名称
    private String stringValue;//文本值
    private Double value;//指标值
    private Integer level;//告警级别
    private Boolean online; //联网状态
    private Boolean alarm;//是否告警
}
```

（2）NoticeService新增方法定义

```java
/**
 * 告警数据透传
 * @param deviceInfoDTO
 */
void alarmTransfer(DeviceInfoDTO deviceInfoDTO);
```

NoticeServiceImpl实现告警逻辑

```java
@Autowired
private RedisTemplate redisTemplate;


@Override
public void alarmTransfer(DeviceInfoDTO deviceInfoDTO) {
    String deviceId = deviceInfoDTO.getDevice().getDeviceId();  //设备id

    for( QuotaDTO quotaDTO:deviceInfoDTO.getQuotaList() ){
        AlarmMsg msg = new AlarmMsg();//告警消息封装
        BeanUtils.copyProperties(quotaDTO,msg);//拷贝属性
        msg.setLevel(Integer.valueOf(quotaDTO.getLevel()));
        
        if(quotaDTO.getAlarm()!=null && quotaDTO.getAlarm().equals("1") && !Strings.isNullOrEmpty(quotaDTO.getAlarmWebhook())  ){  //如果告警且钩子非空，则做数据透传
            //尝试获取
            Object o = redisTemplate.boundValueOps(SystemDefinition.CYCLE_KEY + "_" + deviceId + "_" + quotaDTO.getAlarmName()).get();
            if(o==null){  //如果缓存没有则可以发送告警

                HttpUtil.httpPost(quotaDTO.getAlarmWebhook(),msg); //发送

                //按沉默周期设置过期时间
                redisTemplate.boundValueOps(SystemDefinition.CYCLE_KEY + "_" + deviceId + "_" + quotaDTO.getAlarmName())
                    .set(quotaDTO.getStringValue(), quotaDTO.getCycle(), TimeUnit.MINUTES  );
            }

        }
    }
}
```

（3）修改EmqMsgProcess的messageArrived方法，添加调用告警透传的方法

```java
@Override
public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
    String payload = new String(mqttMessage.getPayload());
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> payloadMap = mapper.readValue(payload, Map.class);
    System.out.println("接收到数据："+payloadMap);
    //解析数据
    DeviceInfoDTO deviceInfoDTO = quotaService.analysis(topic, payloadMap);
    if(deviceInfoDTO!=null){
        //告警判断
        deviceInfoDTO= alarmService.verifyDeviceInfo(deviceInfoDTO);  //返回包含了告警判断的对象
        //保存设备信息
        deviceService.saveDeviceInfo(deviceInfoDTO.getDevice());
        //保存指标数据
        quotaService.saveQuotaToInflux(deviceInfoDTO.getQuotaList());
        //标数据透传
        noticeService.quotaTransfer(deviceInfoDTO.getQuotaList());
        
        //---------告警透传  --------------
        noticeService.alarmTransfer(deviceInfoDTO);
        //-------------------------------
    }

    //处理gps数据
    DeviceLocation deviceLocation = gpsService.analysis(topic, payloadMap);//解析
    if(deviceLocation!=null){
        esRepository.saveLocation(deviceLocation);
    }

}
```

## 4.告警数据实时展示

### 4.1 需求分析

系统接收到设备上报的数据进行过滤匹配之后，发现是需要的监控的指标数据时，将设备上报的报文数据转换成亿可控系统的设备指标状态数据，然后发送到emq的特定主题下，之后前端web页面通过websocket和EMQ建立连接订阅该主题，这样前端页面就能实时收到这些指标数据进行展示了，这样用户可以立即看到设备监控指标的当前状态，用户体验比较好。

### 4.2 实现思路

（1）在后端将设备指标数据构建完成之后，通过mqtt发送到emq

（2）前端通过（wesocket客户端）MQTT协议订阅emq接收数据进行动态展示

### 4.3 代码实现

#### 4.3.1 报警数据前端展示-后端

（1）在NoticeService接口中定义向前端通知数据的方法

```java
/**
     * 告警数据通知
     * @param alarmMsg
     */
void sendDeviceStatusToEmq(AlarmMsg alarmMsg);
```

在实现类`NoticeServiceImpl`中实现该方法

```java
@Autowired
private EmqClient emqClient;

//将告警数据发送到emq
@Override
public void sendDeviceStatusToEmq(AlarmMsg alarmMsg){
    try {
        if(alarmMsg.getLevel() <= 0) return;
        alarmMsg.setAlarm(true);
        emqClient.publish("/device/alarm", JsonUtil.serialize(alarmMsg));
    } catch (JsonProcessingException e) {
        log.error("json序列化失败",e);
    }
}
```

（2）在原来向外部系统透传告警数据的方法里添加代码，调用该方法从而将告警数据发送出去

```java
    @Override
    public void alarmTransfer(DeviceInfoDTO deviceInfoDTO) {
        String deviceId = deviceInfoDTO.getDevice().getDeviceId();  //设备id
        for( QuotaDTO quotaDTO:deviceInfoDTO.getQuotaList() ){
            AlarmMsg msg = new AlarmMsg();//告警消息封装
            BeanUtils.copyProperties(quotaDTO,msg);//拷贝属性
            msg.setLevel(Integer.valueOf(quotaDTO.getLevel()));
            //！！！！！！！！！！！！发送告警数据到前端！！！！！！！！！！！！！！！！！！！
            sendDeviceStatusToEmq(msg);
            if(quotaDTO.getAlarm()!=null && quotaDTO.getAlarm().equals("1") && !Strings.isNullOrEmpty(quotaDTO.getAlarmWebhook())  ){  //如果告警且钩子非空，则做数据透传
                //尝试获取
                Object o = redisTemplate.boundValueOps(SystemDefinition.CYCLE_KEY + "_" + deviceId + "_" + quotaDTO.getAlarmName()).get();
                if(o==null){  //如果缓存没有则可以发送告警
                    HttpUtil.httpPost(quotaDTO.getAlarmWebhook(),msg); //发送
                    //按沉默周期设置过期时间
                    redisTemplate.boundValueOps(SystemDefinition.CYCLE_KEY + "_" + deviceId + "_" + quotaDTO.getAlarmName())
                            .set(quotaDTO.getStringValue(), quotaDTO.getCycle(), TimeUnit.MINUTES  );
                }
            }
        }
    }
```

#### 4.3.2 断网前端展示-后端

（1）DeviceService新增方法定义

```java
/**
 * 断网警告
 * @param deviceId
 */
void disconnectionAlarm(String deviceId);
```

`DeviceServiceImpl`类实现`disconnectionAlarm`方法

```java
@Autowired
private NoticeService noticeService;

@Override
public void disconnectionAlarm(String deviceId) {
    //以web开头的client为系统前端,monitor开头的是亿可控服务端
    if(deviceId.startsWith("webclient") || deviceId.startsWith("monitor")){
        return;
    }
    AlarmMsg alarmMsg = new AlarmMsg();
    alarmMsg.setLevel(1);
    alarmMsg.setAlarmName("设备断网");
    alarmMsg.setDeviceId(deviceId);
    alarmMsg.setOnline(false);
    noticeService.sendDeviceStatusToEmq(alarmMsg); 
}
```

#### 4.3.3 前端代码

前端核心代码实现

```js
import mqtt from 'mqtt';
getMqttData(){
    var client  = mqtt.connect('ws://172.17.0.231/mqtt', {
      port: 8083,
      clientId: 'webclient' + Math.floor(Math.random()*1000),
      username: 'admin',
      password: '123456',
      clean: true
    })
    client.on('connect', function () {
      client.subscribe('presence', function (err) {
        console.log('连接成功:')
        client.subscribe('/device/alarm', { qos: 1 }, (error:any) => {
          if (!error) {
            console.log('订阅成功')
          } else {
            console.log('订阅失败')
          }
        })
      })
    })
    // 接收消息处理
    client.on('message', (topic, message) => {
      // console.log('收到来自', topic, '的消息', message.toString())
      let msg:{[index:string]:any} = JSON.parse(message.toString())
      msg.time = (this as any).moment().format('YYYY-MM-DD hh:ss:mm')
      if (this.tableData.length <= 12){
          this.tableData.unshift(msg)
      } else {
        this.tableData.unshift(msg)
        this.tableData.pop()
      }
    })
    // 断开发起重连
    client.on('reconnect', (error:any) => {
      console.log('正在重连:', error)
    })
    // 链接异常处理
    client.on('error', (error:any) => {
      console.log('连接失败:', error)
    })
  }
```

## 5. 缓存优化

### 5.1 mybatisPlus配置二级缓存 

因为在我们的项目中，会很频繁的从emq中接收数据，然后从mysql中查询指标配置数据，为了减轻mysql的查询压力，在mybatis-plus中开启二级缓存，缓存基于redis进行构建，这样我们的亿可控进行分布式横向扩容时关于缓存这块不用做任何单独修改，平滑部署。

（1）在配置中心添加配置开启二级缓存

```yaml
mybatis-plus:
  configuration:
    cache-enabled: true
```

（2）创建类实现org.apache.ibatis.cache.Cache接口：

```java
package com.yikekong.config;

import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.cache.Cache;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.RedisServerCommands;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;

import java.util.Set;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

@Slf4j
public class MybatisRedisCache implements Cache {

    // 读写锁
    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(true);

    //这里使用了redis缓存，使用springboot自动注入
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private String id;

    public MybatisRedisCache(final String id) {
        if (id == null) {
            throw new IllegalArgumentException("Cache instances require an ID");
        }
        this.id = id;
    }

    @Override
    public String getId() {
        return this.id;
    }

    @Override
    public void putObject(Object key, Object value) {
        if (redisTemplate == null) {
            //由于启动期间注入失败，只能运行期间注入，这段代码可以删除
            redisTemplate = (RedisTemplate<String, Object>) SpringUtil.getBean("redisTemplate");
        }
        if (value != null) {
            redisTemplate.opsForValue().set(key.toString(), value);
        }
    }

    @Override
    public Object getObject(Object key) {
        try {
            if (redisTemplate == null) {
                //由于启动期间注入失败，只能运行期间注入，这段代码可以删除
                redisTemplate = (RedisTemplate<String, Object>) SpringUtil.getBean("redisTemplate");
            }
            if (key != null) {
                return redisTemplate.opsForValue().get(key.toString());
            }
        } catch (Exception e) {
            log.error("缓存出错 ",e);
        }
        return null;
    }

    @Override
    public Object removeObject(Object key) {
        if (redisTemplate == null) {
            //由于启动期间注入失败，只能运行期间注入，这段代码可以删除
            redisTemplate = (RedisTemplate<String, Object>) SpringUtil.getBean("redisTemplate");
        }
        if (key != null) {
            redisTemplate.delete(key.toString());
        }
        return null;
    }

    @Override
    public void clear() {
        log.debug("清空缓存");
        if (redisTemplate == null) {
            redisTemplate = (RedisTemplate<String, Object>) SpringUtil.getBean("redisTemplate");
        }
        Set<String> keys = redisTemplate.keys("*:" + this.id + "*");
        if (!keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }

    @Override
    public int getSize() {
        if (redisTemplate == null) {
            //由于启动期间注入失败，只能运行期间注入，这段代码可以删除
            redisTemplate = (RedisTemplate<String, Object>) SpringUtil.getBean("redisTemplate");
        }
        Long size = redisTemplate.execute((RedisCallback<Long>) RedisServerCommands::dbSize);
        return size.intValue();
    }

    @Override
    public ReadWriteLock getReadWriteLock() {
        return this.readWriteLock;
    }
}
```

（3）需要在对应的mybatis-plus中的Mapper接口上加上

```java
@CacheNamespace(implementation= MybatisRedisCache.class,eviction=MybatisRedisCache.class)
```

注解就自动为该mapper对应的查询逻辑加上缓存了，并且如果执行更新操作的话会自动删除缓存，下次查询会自动查一次库。

### 5.2 设备查询缓存优化

按照我们之前编写的逻辑，每次报文上来都需要从es中查询是否存在该设备。这样对es造成很大的查询压力，所以我们需要使用redis缓存来减轻对es的查询压力。

（1）修改 DeviceServiceImpl的findDevice方法，改从Redis查询

```java
/**
 * 根据设备id查询设备
 * @param deviceId
 * @return
 */
private DeviceDTO findDevice(String deviceId){
    //DeviceDTO deviceDTO = esRepository.searchDeviceById(deviceId);
    DeviceDTO deviceDTO = (DeviceDTO)redisTemplate.boundHashOps(SystemDefinition.DEVICE_KEY).get(deviceId);
    if(deviceDTO == null){
        deviceDTO = esRepository.searchDeviceById(deviceId);
        refreshDevice(deviceDTO);
    }
    return deviceDTO;
}
```

（2）DeviceServiceImpl新增刷新缓存的方法

```java
/**
 * 刷新缓存
 * @param deviceDTO
 */
private void refreshDevice(DeviceDTO deviceDTO) {
    if(deviceDTO == null) return;
 redisTemplate.boundHashOps(SystemDefinition.DEVICE_KEY).put(deviceDTO.getDeviceId(),deviceDTO );
}
```

（3）修改DeviceServiceImpl的saveDeviceInfo方法

```java
@Override
public boolean saveDeviceInfo(DeviceDTO deviceDTO) {
    //在es中查询设备
    DeviceDTO device= findDevice(deviceDTO.getDeviceId());
    if (!device.getStatus()) return false;//如果设备关闭，不进行任何操作
   
    if(device==null){ //如果没有找到就新增
        esRepository.addDevices(deviceDTO);
    }else{
        esRepository.updateDevicesAlarm(deviceDTO);  //更新告警信息
    }
    refreshDevice(deviceDTO);//刷新到缓存
    return true;
}
```

（4）修改DeviceServiceImpl的setStatus方法

```java
@Override
public boolean setStatus(String deviceId, Boolean status) {
    DeviceDTO deviceDTO = findDevice(deviceId);
    if(deviceDTO == null){
        return false;
    }
    esRepository.updateStatus(deviceId,status);
    //刷新到缓存
    deviceDTO.setStatus(status);
    refreshDevice(deviceDTO);
    
    return true;
}
```



## 6. docker-compose项目部署 

### 6.1 什么是docker-compose  

 Docker-compose是一个定义和运行多个Docker应用的工具，我们可以使用YMAL文件来配置我们的服务，然后使用docker-compose命令，创建和启动所有已经配置好的服务。compose可以在任何工作环境中使用，生产环境，开发环境，持续集成等等。 

容器意味着在现代软件堆栈中提供组件隔离。 将数据库放在一个容器中，将Web应用程序放在另一个容器中，并且可以将它们全部缩放，管理，重新启动并独立换出。 但是开发和测试一个多容器应用程序并不像一次使用一个容器。

Docker Compose由Docker创建，用于简化开发和测试多容器应用程序的过程。 这是一个比较像Docker客户端的命令行工具，它接收一个特殊格式的描述符文件(yaml格式的文件)，将应用程序从多个容器中组装出来，并在单个主机上一起运行。

在Docker Compose中，每一个应用程序都是一个Service，通过定义一些Service将这些容器编排组织起来，方便我们在每一台服务器上进行部署和后期管理。

### 6.2 部署应用程序依赖的中间件  

所有的依赖docker-compose去部署到docker容器的服务或程序都要通过编写docker-compose.yml文件来定义容器，假设我们已经具备了docker环境和docker compose环境，我们先来编写外部依赖的这些中间的docker-compose.yml文件：

```yaml
version: "3"
services:
  db:
    image: mysql:8.0.20
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    container_name: db
    privileged: true
    environment:
      MYSQL_ROOT_PASSWORD: root123
      TZ: Asia/Shanghai
    ports:
      - 3306:3306
    volumes:
      - /root/common/data/mysql:/var/lib/mysql
      - /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime

  emq:
    image: emqx/emqx:v4.1.0
    restart: always
    container_name: emqx
    privileged: true
    ports:
      - 18083:18083
      - 8081:8081
      - 8083:8083
      - 8084:8084
      - 1883:1883
    volumes:
      - /root/common/data/emq/emqx.conf:/opt/emqx/etc/emqx.conf
      - /root/common/data/emq/plugins:/opt/emqx/etc/plugins

  redis:
    image: redis:6.0.5
    container_name: redis
    expose:
      - 6379
    volumes:
      - /root/common/data/redis:/data
      - /root/common/data/redis/redis.conf:/etc/redis/redis.conf
    privileged: true
    ports:
      - 6379:6379
    command: redis-server /etc/redis/redis.conf --appendonly yes

  consulServer:
    image: consul:1.7.4
    container_name: consulServer
    restart: always
    privileged: true
    expose:
      - "8500"
    ports:
      - "8500:8500"
      - "8600:8600"
      - "8600:8600/udp"
      - "8300:8300"
      - "8301:8301"
      - "8301:8301/udp"
      - "8400:8400"
      - "8302:8302"
      - "8302:8302/udp"
    volumes:
      - /root/common/data/consul/data:/consul/data
    network_mode: "host"
    command: consul agent -server -bootstrap-expect 1 -data-dir=/consul/data -bind=127.0.0.1 -datacenter=dc1 -ui -node=s1 -client=0.0.0.0

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.7.1
    container_name: es
    restart: always
    ports:
      - 9200:9200
      - 9300:9300
      - 9100:9100
    environment:
      - ES_JAVA_POTS="-Xms512m -Xmx512m"
      - discovery.type=single-node
      - TZ=Asia/Shanghai
    privileged: true
    volumes:
      - /root/common/data/es/data:/usr/share/elasticsearch/data
      - /root/common/data/es/logs:/usr/share/elasticsearch/logs
      - /root/common/data/es/plugins:/usr/share/elasticsearch/plugins

  influxdb:
    image: influxdb:1.8.0
    container_name: influxdb
    restart: always
    ports:
      - 9083:8083
      - 8086:8086
      - 8088:8088
    privileged: true
    volumes:
      - /root/common/data/influxdb:/var/lib/influxdb
      - /root/common/data/influxdb/influxdb.conf:/etc/influxdb/influxdb.conf
```

我们在该文件中定义了6个服务，分别是db(mysql)、emq、redis、consulServer(consul服务端)、elasticsearch、influxdb，这些都是我们程序依赖的中间。

- image： 指定容器运行的镜像、基于哪个容器镜像进行运行
- command：容器启动之后要执行的命令
- restart：重启策略。 no：是默认的重启策略，在任何情况下都不会重启容器； always：容器总是在自动退出后自动重新启动； on-failure：在容器非正常退出时（退出状态非0），才会重启容器； unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 
- container_name：容器名称定义
- privileged：获取特权
- environment：定义环境变量
- ports：宿主机和容器端口映射
- volumes：宿主机和容器目录挂载映射

然后我们将该文件里需要挂载的服务器宿主机上的目录创建完成，在该文件所在目录运行`docker-compose up`或`docker-compose up -d`命令就可以将这些服务都跑到docker容器里了。

带`-d`参数的是在后台运行。

### 6.3 部署应用程序 

当我们的应用程序开发完毕之后，也需要部署到docker里，如果也需要通过docker-compose进行编排部署的话，会有不同。需要以下几步：

创建Dockerfile文件：

```dockerfile
FROM openjdk:8-jre
VOLUME /temp
ENV TZ=Asia/Shanghai
ADD ["app.jar","app.jar"]
EXPOSE 9004
ENTRYPOINT ["java","-jar","app.jar"]
```

将我们的程序重命名成`app.jar`之后复制到和Dockerfile同一个目录下，为目录起名为`backendService`，然后我们在该目录的上级目录中编写`docker-compose.yml`文件：

```yaml
version: "2"
services:
  #后台服务
  backend-service:
    build: backendService
    container_name: backend-Service
    expose:
      - "9093"
    ports:
      - "9093:9093"
    privileged: true
```

build：容器基于构建好的镜像运行，镜像构建基于backendService目录里定义的Dockerfile文件。

最后在`docker-compose.yml`文件所在目录运行`docker-compose build`来构建镜像，然后再执行`docker-compose up -d`来运行我们的容器。





## 疑问代码

有一块代码，需要确认位置

```
    /**
     * 获取设备gps信息
     * @param deviceId
     * @return
     */
    public String getDeviceLocation(String deviceId){
        SearchRequest searchRequest = new SearchRequest("gps");
        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
        searchSourceBuilder.query(QueryBuilders.termQuery("_id",deviceId));
        searchRequest.source(searchSourceBuilder);
        try {
            SearchResponse searchResponse = client.search(searchRequest,RequestOptions.DEFAULT);
            SearchHits hits = searchResponse.getHits();
            Long hitsCount = hits.getTotalHits().value;
            if(hitsCount <= 0) return "";
            for(SearchHit hit : hits){
                String hitResult = hit.getSourceAsString();
                String location = JsonUtil.getValueByNodeName("location",hitResult);

                return location;
            }
            //client.close();

            return "";
        } catch (IOException e) {
            log.error("search by id error",e);

            return "";
        }
    }

```



ESConfig没用到？

```
package com.yikekong.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties("es")
public class ESConfig{
    private String hostname;
    private int port;

    public String getHostname() {
        return hostname;
    }

    public void setHostname(String hostname) {
        this.hostname = hostname;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }
}

```





```
package com.yikekong.config;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class SpringUtil implements ApplicationContextAware{

    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        SpringUtil.applicationContext = applicationContext;
    }

    public static Object getBean(String name){
        return applicationContext.getBean(name);
    }

    public static <T> T getBean(String name, Class<T> clazz){
        return applicationContext.getBean(name, clazz);
    }

    public static <T> T getBean(Class<T> clazz){
        return applicationContext.getBean(clazz);
    }
}

```

